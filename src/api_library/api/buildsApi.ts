/**
 * Unity Cloud Build
 * This API is intended to be used in conjunction with the Unity Cloud Build service. A tool for building your Unity projects in the Cloud.  See https://developer.cloud.unity3d.com for more information.  ## Making requests This website is built to allow requests to be made against the API. If you are currently logged into Cloud Build you should be able to make requests without entering an API key.   You can find your API key in the Unity Cloud Services portal by clicking on \'Cloud Build Preferences\' in the sidebar. Copy the API Key and paste it into the upper left corner of this website. It will be used in all subsequent requests.  ## Clients The Unity Cloud Build API is based upon Swagger. Client libraries to integrate with your projects can easily be generated with the [Swagger Code Generator](https://github.com/swagger-api/swagger-codegen).  The JSON schema required to generate a client for this API version is located here:  ``` [API_URL][BASE_PATH]/api.json ```  ## Authorization The Unity Cloud Build API requires an access token from your Unity Cloud Build account, which can be found at https://build.cloud.unity3d.com/login/me  To authenticate requests, include a Basic Authentication header with your API key as the value. e.g.  ``` Authorization: Basic [YOUR API KEY] ```  ## Pagination Paged results will take two parameters. A page number that is calculated based upon the per_page amount. For instance if there are 40 results and you specify page 2 with per_page set to 10 you will receive records 11-20.  Paged results will also return a Content-Range header. For the example above the content range header would look like this:  ``` Content-Range: items 11-20/40 ```  ## Versioning The API version is indicated in the request URL. Upgrading to a newer API version can be done by changing the path.  The API will receive a new version in the following cases:    * removal of a path or request type   * addition of a required field   * removal of a required field  The following changes are considered backwards compatible and will not trigger a new API version:    * addition of an endpoint or request type   * addition of an optional field   * removal of an optional field   * changes to the format of ids  ## Identifiers It should not be assumed that any of the identifiers used in paths will be a perfect match for your user-entered information. If you see unexpected 403s or 404s from API calls then check your identifiers match the ones used by the API. In particular, `projectId` does NOT typically change when the project is renamed and in fact may not be a direct match for the project name even at initial creation time.  To avoid confusion we recommend that instead of using the human-readable autogenerated orgId and projectId available from the API you should instead use:   * org foreign key for `orgId` (available from project APIs as `orgFk` and org APIs as `coreForeignKey`)   * `guid` for `projectId`  All links generated by the API and the Dashboard should follow this format already, making it easy to figure out the correct parameters by making a comparison.  ## Rate Limiting Requests against the Cloud Build API are limited to a rate of 100 per minute. To preserve the quality of service throughout Cloud Build, additional rate limits may apply to some actions. For example, polling aggressively instead of using webhooks or making API calls with a high concurrency may result in rate limiting.  It is not intended for these rate limits to interfere with any legitimate use of the API. Please contact support at <cloudbuild@unity3d.com> if your use is affected by this rate limit.  You can check the returned HTTP headers for any API request to see your current rate limit status.   * __X-RateLimit-Limit:__ maximum number of requests per minute   * __X-RateLimit-Remaining:__ remaining number of requests in the current window   * __X-RateLimit-Reset:__ time at which the current window will reset (UTC epoch seconds)  Once you go over the rate limit you will receive an error response: ``` HTTP Status: 429 {   \"error\": \"Rate limit exceeded, retry in XX seconds\" } ``` 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { InlineObject10 } from '../model/inlineObject10';
import { InlineObject8 } from '../model/inlineObject8';
import { InlineObject9 } from '../model/inlineObject9';
import { InlineResponse20011 } from '../model/inlineResponse20011';
import { InlineResponse2006 } from '../model/inlineResponse2006';
import { OrgsOrgidProjectsProjectidBuildtargetsBuilds } from '../model/orgsOrgidProjectsProjectidBuildtargetsBuilds';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost/api/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum BuildsApiApiKeys {
}

export class BuildsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apikey': new HttpBasicAuth(),
        'permissions': new OAuth(),
        'filetoken': new HttpBasicAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: BuildsApiApiKeys, value: string) {
        (this.authentications as any)[BuildsApiApiKeys[key]].apiKey = value;
    }

    set username(username: string) {
        this.authentications.apikey.username = username;
    }

    set password(password: string) {
        this.authentications.apikey.password = password;
    }

    set accessToken(token: string) {
        this.authentications.permissions.accessToken = token;
    }

    set username(username: string) {
        this.authentications.filetoken.username = username;
    }

    set password(password: string) {
        this.authentications.filetoken.password = password;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Delete all artifacts associated with the builds identified by the provided build target ids and build numbers. Builds marked as do not delete or that are currently building will be ignored. 
     * @summary Delete artifacts for a batch of builds
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param options 
     */
    public async batchDeleteBuildArtifacts (orgid: string, projectid: string, options: InlineObject8, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/artifacts/delete'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling batchDeleteBuildArtifacts.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling batchDeleteBuildArtifacts.');
        }

        // verify required parameter 'options' is not null or undefined
        if (options === null || options === undefined) {
            throw new Error('Required parameter options was null or undefined when calling batchDeleteBuildArtifacts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(options, "InlineObject8")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Cancel all builds in progress for this build target (or all targets, if \'_all\' is specified as the buildtargetid). Canceling an already finished build will do nothing and respond successfully. 
     * @summary Cancel all builds
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     */
    public async cancelAllBuilds (orgid: string, projectid: string, buildtargetid: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling cancelAllBuilds.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling cancelAllBuilds.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling cancelAllBuilds.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Cancel a build in progress. Canceling an already finished build will do nothing and respond successfully. 
     * @summary Cancel build
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     */
    public async cancelBuild (orgid: string, projectid: string, buildtargetid: string, number: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling cancelBuild.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling cancelBuild.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling cancelBuild.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling cancelBuild.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Cancel all in progress builds for an organization. Canceling an already finished build will do nothing and respond successfully. 
     * @summary Cancel builds for org
     * @param orgid Organization identifier
     */
    public async cancelBuildsForOrg (orgid: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/builds'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling cancelBuildsForOrg.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new short link to share a project. If this is called when a share already exists, that share will be revoked and a new one created.
     * @summary Create a new link to share a project
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     * @param shareExpiry 
     */
    public async createShare (orgid: string, projectid: string, buildtargetid: string, number: string, shareExpiry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/share'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling createShare.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling createShare.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling createShare.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling createShare.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (shareExpiry !== undefined) {
            localVarFormParams['shareExpiry'] = ObjectSerializer.serialize(shareExpiry, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "object");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete all artifacts associated with all non-favorited builds for a specified buildtargetid (_all is allowed).
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     */
    public async deleteAllBuildArtifacts (orgid: string, projectid: string, buildtargetid: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/artifacts'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling deleteAllBuildArtifacts.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling deleteAllBuildArtifacts.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling deleteAllBuildArtifacts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete all artifacts associated with a specific build
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     */
    public async deleteBuildArtifacts (orgid: string, projectid: string, buildtargetid: string, number: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/artifacts'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling deleteBuildArtifacts.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling deleteBuildArtifacts.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling deleteBuildArtifacts.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling deleteBuildArtifacts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve a list of settings changes between the last and current build.
     * @summary Get audit log
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     * @param perPage Number of audit log records to retrieve
     * @param page Skip to page number, based on per_page value
     */
    public async getAuditLog (orgid: string, projectid: string, buildtargetid: string, number: string, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<InlineResponse2006>;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/auditlog'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling getAuditLog.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling getAuditLog.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling getAuditLog.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling getAuditLog.');
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<InlineResponse2006>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<InlineResponse2006>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve a list of historical settings changes for this build target.
     * @summary Get audit log
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param perPage Number of audit log records to retrieve
     * @param page Skip to page number, based on per_page value
     */
    public async getAuditLogForBuildTarget (orgid: string, projectid: string, buildtargetid: string, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<InlineResponse2006>;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/auditlog'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling getAuditLogForBuildTarget.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling getAuditLogForBuildTarget.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling getAuditLogForBuildTarget.');
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<InlineResponse2006>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<InlineResponse2006>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve information for a specific build. A Build resource contains information related to a build attempt for a build target, including the build number, changeset, build times, and other pertinent data. 
     * @summary Build Status
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     * @param include Extra fields to include in the response
     */
    public async getBuild (orgid: string, projectid: string, buildtargetid: string, number: string, include?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv', 'application/json-accepted'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling getBuild.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling getBuild.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling getBuild.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling getBuild.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.filetoken.username && this.authentications.filetoken.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.filetoken.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "object");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve the plain text log for a specifc build.
     * @summary Get build log
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     * @param offsetlines Stream log from the given line number
     * @param linenumbers Include log line numbers in the text output
     * @param lastLineNumber The last line number seen, numbering will continue from here
     * @param compact Return the compact log, showing only errors and warnings
     * @param withHtml Surround important lines (errors, warnings) with SPAN and CSS markup 
     */
    public async getBuildLog (orgid: string, projectid: string, buildtargetid: string, number: string, offsetlines?: number, linenumbers?: boolean, lastLineNumber?: number, compact?: boolean, withHtml?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/log'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['text/plain-full', 'text/plain-compact', 'text/html-compact', 'application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling getBuildLog.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling getBuildLog.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling getBuildLog.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling getBuildLog.');
        }

        if (offsetlines !== undefined) {
            localVarQueryParameters['offsetlines'] = ObjectSerializer.serialize(offsetlines, "number");
        }

        if (linenumbers !== undefined) {
            localVarQueryParameters['linenumbers'] = ObjectSerializer.serialize(linenumbers, "boolean");
        }

        if (lastLineNumber !== undefined) {
            localVarQueryParameters['lastLineNumber'] = ObjectSerializer.serialize(lastLineNumber, "number");
        }

        if (compact !== undefined) {
            localVarQueryParameters['compact'] = ObjectSerializer.serialize(compact, "boolean");
        }

        if (withHtml !== undefined) {
            localVarQueryParameters['withHtml'] = ObjectSerializer.serialize(withHtml, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieves all build steps for a build, this replaces the old method where we would manually download the build report artifacts and allows us to add more functionality into build steps. 
     * @summary Get the build steps for a given build
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     */
    public async getBuildSteps (orgid: string, projectid: string, buildtargetid: string, number: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<InlineResponse20011>;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/steps'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling getBuildSteps.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling getBuildSteps.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling getBuildSteps.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling getBuildSteps.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<InlineResponse20011>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<InlineResponse20011>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List all running and finished builds, sorted by build number (optionally paginating the results). Use \'_all\' as the buildtargetid to get all configured build targets. The response includes a Content-Range header that identifies the range of results returned and the total number of results matching the given query parameters. 
     * @summary List all builds
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param include Extra fields to include in the response
     * @param perPage Number of audit log records to retrieve
     * @param page Skip to page number, based on per_page value
     * @param buildStatus Query for only builds of a specific status
     * @param platform Query for only builds of a specific platform
     * @param showDeleted Query for builds that have been deleted
     * @param onlyFavorites Query for builds that have been favorited
     * @param cleanBuild Query for builds that have either been built clean or using caches
     */
    public async getBuilds (orgid: string, projectid: string, buildtargetid: string, include?: string, perPage?: number, page?: number, buildStatus?: string, platform?: string, showDeleted?: boolean, onlyFavorites?: boolean, cleanBuild?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling getBuilds.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling getBuilds.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling getBuilds.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "string");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (buildStatus !== undefined) {
            localVarQueryParameters['buildStatus'] = ObjectSerializer.serialize(buildStatus, "string");
        }

        if (platform !== undefined) {
            localVarQueryParameters['platform'] = ObjectSerializer.serialize(platform, "string");
        }

        if (showDeleted !== undefined) {
            localVarQueryParameters['showDeleted'] = ObjectSerializer.serialize(showDeleted, "boolean");
        }

        if (onlyFavorites !== undefined) {
            localVarQueryParameters['onlyFavorites'] = ObjectSerializer.serialize(onlyFavorites, "boolean");
        }

        if (cleanBuild !== undefined) {
            localVarQueryParameters['cleanBuild'] = ObjectSerializer.serialize(cleanBuild, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List all running and finished builds, sorted by build number (optionally paginating the results). The response includes a Content-Range header that identifies the range of results returned and the total number of results matching the given query parameters. 
     * @summary List all builds for org
     * @param orgid Organization identifier
     * @param include Extra fields to include in the response
     * @param perPage Number of audit log records to retrieve
     * @param page Skip to page number, based on per_page value
     * @param buildStatus Query for only builds of a specific status
     * @param platform Query for only builds of a specific platform
     * @param showDeleted Query for builds that have been deleted
     * @param onlyFavorites Query for builds that have been favorited
     * @param cleanBuild Query for builds that have either been built clean or using caches
     */
    public async getBuildsForOrg (orgid: string, include?: string, perPage?: number, page?: number, buildStatus?: string, platform?: string, showDeleted?: boolean, onlyFavorites?: boolean, cleanBuild?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/builds'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling getBuildsForOrg.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "string");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (buildStatus !== undefined) {
            localVarQueryParameters['buildStatus'] = ObjectSerializer.serialize(buildStatus, "string");
        }

        if (platform !== undefined) {
            localVarQueryParameters['platform'] = ObjectSerializer.serialize(platform, "string");
        }

        if (showDeleted !== undefined) {
            localVarQueryParameters['showDeleted'] = ObjectSerializer.serialize(showDeleted, "boolean");
        }

        if (onlyFavorites !== undefined) {
            localVarQueryParameters['onlyFavorites'] = ObjectSerializer.serialize(onlyFavorites, "boolean");
        }

        if (cleanBuild !== undefined) {
            localVarQueryParameters['cleanBuild'] = ObjectSerializer.serialize(cleanBuild, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets a share link if it exists
     * @summary Get the share link
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     */
    public async getShare (orgid: string, projectid: string, buildtargetid: string, number: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/share'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling getShare.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling getShare.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling getShare.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling getShare.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "object");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Modify an existing share link. Only intended for updating the Expiry without revoking the link.
     * @summary Modify existing share link
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     * @param shareExpiry 
     */
    public async modifyShare (orgid: string, projectid: string, buildtargetid: string, number: string, shareExpiry?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/share'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling modifyShare.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling modifyShare.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling modifyShare.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling modifyShare.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (shareExpiry !== undefined) {
            localVarFormParams['shareExpiry'] = ObjectSerializer.serialize(shareExpiry, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "object");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Re-sign a build artifact using the most recent credentials associated with the buildtarget. 
     * @summary Re-sign a build artifact
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     */
    public async resignBuildArtifact (orgid: string, projectid: string, buildtargetid: string, number: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/resign'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv', 'application/json-accepted', 'application/json-already-building'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling resignBuildArtifact.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling resignBuildArtifact.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling resignBuildArtifact.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling resignBuildArtifact.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Revoke a shared link, both {buildtargetid} and {number} may use _all to revoke all share links for a given buildtarget or entire project.
     * @summary Revoke a shared link
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     */
    public async revokeShare (orgid: string, projectid: string, buildtargetid: string, number: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}/share'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling revokeShare.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling revokeShare.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling revokeShare.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling revokeShare.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "string");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Start the build process for this build target (or all targets, if \'_all\' is specified as the buildtargetid), if there is not one currently in process.  If a build is currently in process that information will be related in the \'error\' field. 
     * @summary Create new build
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param options 
     */
    public async startBuilds (orgid: string, projectid: string, buildtargetid: string, options?: InlineObject9, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv', 'application/json-accepted', 'application/json-already-building'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling startBuilds.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling startBuilds.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling startBuilds.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(options, "InlineObject9")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<OrgsOrgidProjectsProjectidBuildtargetsBuilds>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Update build information
     * @param orgid Organization identifier
     * @param projectid Project identifier
     * @param buildtargetid unique id auto-generated from the build target name
     * @param number Build number or in some cases _all
     * @param options 
     */
    public async updateBuild (orgid: string, projectid: string, buildtargetid: string, number: string, options: InlineObject10, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/orgs/{orgid}/projects/{projectid}/buildtargets/{buildtargetid}/builds/{number}'
            .replace('{' + 'orgid' + '}', encodeURIComponent(String(orgid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)))
            .replace('{' + 'buildtargetid' + '}', encodeURIComponent(String(buildtargetid)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/plain', 'text/html', 'text/csv', 'application/json-accepted'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'orgid' is not null or undefined
        if (orgid === null || orgid === undefined) {
            throw new Error('Required parameter orgid was null or undefined when calling updateBuild.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling updateBuild.');
        }

        // verify required parameter 'buildtargetid' is not null or undefined
        if (buildtargetid === null || buildtargetid === undefined) {
            throw new Error('Required parameter buildtargetid was null or undefined when calling updateBuild.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling updateBuild.');
        }

        // verify required parameter 'options' is not null or undefined
        if (options === null || options === undefined) {
            throw new Error('Required parameter options was null or undefined when calling updateBuild.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(options, "InlineObject10")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.apikey.username && this.authentications.apikey.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.apikey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.permissions.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.permissions.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "object");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
